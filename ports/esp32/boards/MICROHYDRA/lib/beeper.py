from machine import I2S, Pin
import time
import math


#This is a simple sound module that uses pre-generated sin-waves for quickly playing short ui beeps.
#The sound quality from this module could probably be improved, especially because the results seem to be out of tune. However, for now, this works well for simple UI beeps.

# one loop of a sin wave. #25hz
fast_sin = const(b'\x7f\x7f\x83\x83\x88\x88\x8d\x8d\x92\x92\x97\x97\x9c\x9c\xa1\xa1\xa6\xa6\xaa\xaa\xaf\xaf\xb4\xb4\xb8\xb8\xbd\xbd\xc1\xc1\xc5\xc5\xc9\xc9\xcd\xcd\xd1\xd1\xd5\xd5\xd8\xd8\xdc\xdc\xdf\xdf\xe2\xe2\xe5\xe5\xe8\xe8\xeb\xeb\xed\xed\xf0\xf0\xf2\xf2\xf4\xf4\xf6\xf6\xf7\xf7\xf9\xf9\xfa\xfa\xfb\xfb\xfc\xfc\xfd\xfd\xfd\xfd\xfd\xfd\xfe\xfe\xfd\xfd\xfd\xfd\xfd\xfd\xfc\xfc\xfb\xfb\xfa\xfa\xf9\xf9\xf7\xf7\xf6\xf6\xf4\xf4\xf2\xf2\xf0\xf0\xed\xed\xeb\xeb\xe8\xe8\xe5\xe5\xe2\xe2\xdf\xdf\xdc\xdc\xd8\xd8\xd5\xd5\xd1\xd1\xcd\xcd\xc9\xc9\xc5\xc5\xc1\xc1\xbd\xbd\xb8\xb8\xb4\xb4\xaf\xaf\xaa\xaa\xa6\xa6\xa1\xa1\x9c\x9c\x97\x97\x92\x92\x8d\x8d\x88\x88\x83\x83~~zzuuppkkffaa\\\\WWSSNNIIEE@@<<884400,,((%%!!\x1e\x1e\x1b\x1b\x18\x18\x15\x15\x12\x12\x10\x10\r\r\x0b\x0b\t\t\x07\x07\x06\x06\x04\x04\x03\x03\x02\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x02\x02\x03\x03\x04\x04\x06\x06\x07\x07\t\t\x0b\x0b\r\r\x10\x10\x12\x12\x15\x15\x18\x18\x1b\x1b\x1e\x1e!!%%((,,004488<<@@EEIINNSSWW\\\\aaffkkppuuzz')

greensleeves = const('A4 A4 C5 C5 C5 C5 D5 D5 E5 E5 E5 E5 F5 E5 D5 D5 D5 D5 B4 B4 G4 G4 G4 G4 A4 B4 C5 C5 C5 C5 A4 A4 A4 A4 GS4 GS4 A4 A4 B4 B4 B4 B4 - GS4 GS4 E4 E4 E4 E4 A4 A4 C5 C5 C5 C5 D5 D5 E5 E5 E5 E5 F5 E5 D5 D5 D5 D5 B4 B4 G4 G4 G4 G4 A4 B4 C5 C5 B4 B4 A4 A4 GS4 GS4 - FS4 FS4 - GS4 GS4 - A4 A4 A4 A4 A4 A4 - A4 A4 A4 A4 A4 A4 - G5 G5 G5 G5 - G5 G5 G5 G5 - FS5 E5 D5 D5 D5 D5 - B4 B4 G4 G4 G4 G4 A4 B4 C5 C5 C5 C5 - A4 A4 - A4 A4 GS4 GS4 A4 A4 B4 B4 B4 B4 GS4 GS4 E4 E4 E4 E4 - G5 G5 G5 G5 - G5 G5 G5 G5 - FS5 E5 D5 D5 D5 D5 - B4 B4 G4 G4 G4 G4 A4 B4 C5 C5 - B4 B4 - A4 A4 - GS4 GS4 - FS4 FS4 - - GS4 GS4 - - - A4 A4 A4 A4 A4 A4 - - A4 A4 A4 A4 A4 A4')

fast_sin_len = const(320)
fast_sin_hz = const(25)
SCK_PIN = const(41)
WS_PIN = const(43)
SD_PIN = const(42)
I2S_ID = const(1)
BUFFER_LENGTH_IN_BYTES = const(4000)
SAMPLE_SIZE_IN_BITS = const(16)
FORMAT = I2S.STEREO
SAMPLE_RATE_IN_HZ = const(8000)

tone_map = {
"C3": 131,
"CS3": 139,
"D3": 147,
"DS3": 156,
"E3": 165,
"F3": 175,
"FS3": 185,
"G3": 196,
"GS3": 208,
"A3": 220,
"AS3": 233,
"B3": 247,
"C4": 262,
"CS4": 277,
"D4": 294,
"DS4": 311,
"E4": 330,
"F4": 349,
"FS4": 370,
"G4": 392,
"GS4": 415,
"A4": 440,
"AS4": 466,
"B4": 494,
"C5": 523,
"CS5": 554,
"D5": 587,
"DS5": 622,
"E5": 659,
"F5": 698,
"FS5": 740,
"G5": 784,
"GS5": 831,
"A5": 880,
"AS5": 932,
"B5": 988,
"C6": 1047,
"CS6": 1109,
"D6": 1175,
"-":4000
}




# Beeper object controlls your access to the i2s module, and keeps track of what's playing
class Beeper:
    #TODO: fix the pitch issues with the outputs generated by this class.
    
    def __init__(self):
        
        self._output = I2S(            
            I2S_ID,
            sck=Pin(SCK_PIN),
            ws=Pin(WS_PIN),
            sd=Pin(SD_PIN),
            mode=I2S.TX,
            bits=SAMPLE_SIZE_IN_BITS,
            format=FORMAT,
            rate=SAMPLE_RATE_IN_HZ,
            ibuf=BUFFER_LENGTH_IN_BYTES)
        
        self._current_notes = []
        
        self._mv = memoryview(fast_sin)
        
        self._buf = bytearray(1000)
        self._buf_mv = memoryview(self._buf)
    def __del__(self):
        self._output.deinit()
        
    def fast_sin_gen(self, freq, length_seconds=0.1, volume_shift=-2):
        '''
            generate a frequency from the pre-generated fast sin constant.
            Recommended value range for volume shift: -7 to 2. -8 essentialy mutes it.
            frequencies less than than 8hz will raise an error
        '''
        
        
        sample_length_bytes = math.floor(SAMPLE_RATE_IN_HZ * length_seconds) # "* 2" because its 16 bit audio

        #how many times the fast sin must loop in our sample:
        times_to_loop = math.floor(freq * length_seconds)
        
        sample_length_bytes_once = sample_length_bytes // times_to_loop
        speed_multiplier = freq / fast_sin_hz
        
        if volume_shift < 0:
            for i in range(0,sample_length_bytes_once):
                self._buf[i] = self._mv[math.floor(i * speed_multiplier) % fast_sin_len] >> abs(volume_shift)
        else:
            for i in range(0,sample_length_bytes_once):
                self._buf[i] = self._mv[math.floor(i * speed_multiplier) % fast_sin_len] << volume_shift
            
        #print(self._buf[:sample_length_bytes_once])
        for i in range(0,times_to_loop):
            self._output.write(self._buf_mv[:sample_length_bytes_once])
        
    def play(self, notes, length_seconds=0.1, volume=4):
        '''
            Play given notes for given duration, and of given volume.
            volume is an int value from 0 to 10.
            notes should be a string containing one or more notes separated by spaces.
        '''
        if not 0 <= volume <= 10:
            raise ValueError(f"beep.play got a volume of {volume}, but it should be an int between 0 and 10.")
        notes = notes.split()
        for note in notes:
            self.fast_sin_gen(
                freq=tone_map[note],
                length_seconds=length_seconds,
                volume_shift=volume - 7
                )
        
    
def gen_sin_wave(freq, volume=1):
    # I dont trust this guy.
    radians_increment = (math.pi / SAMPLE_RATE_IN_HZ) * freq
    
    samples = bytearray()
    rads_current = 0
    while rads_current < (math.pi * 2):
        sample = math.floor(math.sin(rads_current) * 127) + 127
        samples += bytearray((sample, sample))
        rads_current += radians_increment
    return samples

    
if __name__ == "__main__":
    beep = Beeper()
    # I imported a greensleeves string I made for another project, and it sounds pretty rough, haha.
    # The timing needs to be fixed, but worse is that the notes are super out of tune. Sounds better out of PWM.
    #beep.play(geensleeves, length_seconds=0.2, volume=1)
    beep = Beeper()
    beep.play('C4 B4 C5 C5',0.14,2)
    del beep
